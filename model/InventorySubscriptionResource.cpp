/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */



#include "InventorySubscriptionResource.h"

namespace io {
namespace swagger {
namespace client {
namespace model {

InventorySubscriptionResource::InventorySubscriptionResource()
{
    m_Bill_date = 0;
    m_Bill_dateIsSet = false;
    m_Credit = 0.0;
    m_CreditIsSet = false;
    m_Credit_logIsSet = false;
    m_Grace_end = 0;
    m_Grace_endIsSet = false;
    m_Inventory_id = 0;
    m_Inventory_idIsSet = false;
    m_Inventory_status = U("");
    m_Inventory_statusIsSet = false;
    m_Item_id = 0;
    m_Item_idIsSet = false;
    m_Payment_methodIsSet = false;
    m_Recurring_price = 0.0;
    m_Recurring_priceIsSet = false;
    m_Sku = U("");
    m_SkuIsSet = false;
    m_Start_date = 0;
    m_Start_dateIsSet = false;
    m_Subscription_status = 0;
    m_Subscription_statusIsSet = false;
    m_UserIsSet = false;
    
}

InventorySubscriptionResource::~InventorySubscriptionResource()
{
}

void InventorySubscriptionResource::validate()
{
    // TODO: implement validation
}

web::json::value InventorySubscriptionResource::toJson() const
{
    web::json::value val = web::json::value::object();

    if(m_Bill_dateIsSet)
    {
        val[U("bill_date")] = ModelBase::toJson(m_Bill_date);
    }
    if(m_CreditIsSet)
    {
        val[U("credit")] = ModelBase::toJson(m_Credit);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Credit_log )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            val[U("credit_log")] = web::json::value::array(jsonArray);
        }
    }
    if(m_Grace_endIsSet)
    {
        val[U("grace_end")] = ModelBase::toJson(m_Grace_end);
    }
    if(m_Inventory_idIsSet)
    {
        val[U("inventory_id")] = ModelBase::toJson(m_Inventory_id);
    }
    if(m_Inventory_statusIsSet)
    {
        val[U("inventory_status")] = ModelBase::toJson(m_Inventory_status);
    }
    if(m_Item_idIsSet)
    {
        val[U("item_id")] = ModelBase::toJson(m_Item_id);
    }
    if(m_Payment_methodIsSet)
    {
        val[U("payment_method")] = ModelBase::toJson(m_Payment_method);
    }
    if(m_Recurring_priceIsSet)
    {
        val[U("recurring_price")] = ModelBase::toJson(m_Recurring_price);
    }
    if(m_SkuIsSet)
    {
        val[U("sku")] = ModelBase::toJson(m_Sku);
    }
    if(m_Start_dateIsSet)
    {
        val[U("start_date")] = ModelBase::toJson(m_Start_date);
    }
    if(m_Subscription_statusIsSet)
    {
        val[U("subscription_status")] = ModelBase::toJson(m_Subscription_status);
    }
    if(m_UserIsSet)
    {
        val[U("user")] = ModelBase::toJson(m_User);
    }
    

    return val;
}

void InventorySubscriptionResource::fromJson(web::json::value& val)
{
    if(val.has_field(U("bill_date")))
    {
        setBillDate(ModelBase::int64_tFromJson(val[U("bill_date")]));
    }
    if(val.has_field(U("credit")))
    {
        setCredit(ModelBase::doubleFromJson(val[U("credit")]));
    }
    {
        m_Credit_log.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(U("credit_log")))
        {
        for( auto& item : val[U("credit_log")].as_array() )
        {
            
            if(item.is_null())
            {
                m_Credit_log.push_back( std::shared_ptr<SubscriptionCreditResource>(nullptr) );
            }
            else
            {
                std::shared_ptr<SubscriptionCreditResource> newItem(new SubscriptionCreditResource());
                newItem->fromJson(item);
                m_Credit_log.push_back( newItem );
            }
            
        }
        }
    }
    if(val.has_field(U("grace_end")))
    {
        setGraceEnd(ModelBase::int64_tFromJson(val[U("grace_end")]));
    }
    if(val.has_field(U("inventory_id")))
    {
        setInventoryId(ModelBase::int32_tFromJson(val[U("inventory_id")]));
    }
    if(val.has_field(U("inventory_status")))
    {
        setInventoryStatus(ModelBase::stringFromJson(val[U("inventory_status")]));
        
    }
    if(val.has_field(U("item_id")))
    {
        setItemId(ModelBase::int32_tFromJson(val[U("item_id")]));
    }
    if(val.has_field(U("payment_method")))
    {
        if(!val[U("payment_method")].is_null())
        {
            std::shared_ptr<PaymentMethodResource> newItem(new PaymentMethodResource());
            newItem->fromJson(val[U("payment_method")]);
            setPaymentMethod( newItem );
        }
        
    }
    if(val.has_field(U("recurring_price")))
    {
        setRecurringPrice(ModelBase::doubleFromJson(val[U("recurring_price")]));
    }
    if(val.has_field(U("sku")))
    {
        setSku(ModelBase::stringFromJson(val[U("sku")]));
        
    }
    if(val.has_field(U("start_date")))
    {
        setStartDate(ModelBase::int64_tFromJson(val[U("start_date")]));
    }
    if(val.has_field(U("subscription_status")))
    {
        setSubscriptionStatus(ModelBase::int32_tFromJson(val[U("subscription_status")]));
    }
    if(val.has_field(U("user")))
    {
        if(!val[U("user")].is_null())
        {
            std::shared_ptr<SimpleUserResource> newItem(new SimpleUserResource());
            newItem->fromJson(val[U("user")]);
            setUser( newItem );
        }
        
    }
    
}

void InventorySubscriptionResource::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    if(m_Bill_dateIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("bill_date"), m_Bill_date));
    }
    if(m_CreditIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("credit"), m_Credit));
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Credit_log )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + U("credit_log"), web::json::value::array(jsonArray), U("application/json")));
        }
    }
    if(m_Grace_endIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("grace_end"), m_Grace_end));
    }
    if(m_Inventory_idIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("inventory_id"), m_Inventory_id));
    }
    if(m_Inventory_statusIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("inventory_status"), m_Inventory_status));
        
    }
    if(m_Item_idIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("item_id"), m_Item_id));
    }
    if(m_Payment_methodIsSet)
    {
        if (m_Payment_method.get())
        {
            m_Payment_method->toMultipart(multipart, U("payment_method."));
        }
        
    }
    if(m_Recurring_priceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("recurring_price"), m_Recurring_price));
    }
    if(m_SkuIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("sku"), m_Sku));
        
    }
    if(m_Start_dateIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("start_date"), m_Start_date));
    }
    if(m_Subscription_statusIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("subscription_status"), m_Subscription_status));
    }
    if(m_UserIsSet)
    {
        if (m_User.get())
        {
            m_User->toMultipart(multipart, U("user."));
        }
        
    }
    
}

void InventorySubscriptionResource::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    if(multipart->hasContent(U("bill_date")))
    {
        setBillDate(ModelBase::int64_tFromHttpContent(multipart->getContent(U("bill_date"))));
    }
    if(multipart->hasContent(U("credit")))
    {
        setCredit(ModelBase::doubleFromHttpContent(multipart->getContent(U("credit"))));
    }
    {
        m_Credit_log.clear();
        if(multipart->hasContent(U("credit_log")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(U("credit_log"))));
        for( auto& item : jsonArray.as_array() )
        {
            
            if(item.is_null())
            {
                m_Credit_log.push_back( std::shared_ptr<SubscriptionCreditResource>(nullptr) );
            }
            else
            {
                std::shared_ptr<SubscriptionCreditResource> newItem(new SubscriptionCreditResource());
                newItem->fromJson(item);
                m_Credit_log.push_back( newItem );
            }
            
        }
        }
    }
    if(multipart->hasContent(U("grace_end")))
    {
        setGraceEnd(ModelBase::int64_tFromHttpContent(multipart->getContent(U("grace_end"))));
    }
    if(multipart->hasContent(U("inventory_id")))
    {
        setInventoryId(ModelBase::int32_tFromHttpContent(multipart->getContent(U("inventory_id"))));
    }
    if(multipart->hasContent(U("inventory_status")))
    {
        setInventoryStatus(ModelBase::stringFromHttpContent(multipart->getContent(U("inventory_status"))));
        
    }
    if(multipart->hasContent(U("item_id")))
    {
        setItemId(ModelBase::int32_tFromHttpContent(multipart->getContent(U("item_id"))));
    }
    if(multipart->hasContent(U("payment_method")))
    {
        if(multipart->hasContent(U("payment_method")))
        {
            std::shared_ptr<PaymentMethodResource> newItem(new PaymentMethodResource());
            newItem->fromMultiPart(multipart, U("payment_method."));
            setPaymentMethod( newItem );
        }
        
    }
    if(multipart->hasContent(U("recurring_price")))
    {
        setRecurringPrice(ModelBase::doubleFromHttpContent(multipart->getContent(U("recurring_price"))));
    }
    if(multipart->hasContent(U("sku")))
    {
        setSku(ModelBase::stringFromHttpContent(multipart->getContent(U("sku"))));
        
    }
    if(multipart->hasContent(U("start_date")))
    {
        setStartDate(ModelBase::int64_tFromHttpContent(multipart->getContent(U("start_date"))));
    }
    if(multipart->hasContent(U("subscription_status")))
    {
        setSubscriptionStatus(ModelBase::int32_tFromHttpContent(multipart->getContent(U("subscription_status"))));
    }
    if(multipart->hasContent(U("user")))
    {
        if(multipart->hasContent(U("user")))
        {
            std::shared_ptr<SimpleUserResource> newItem(new SimpleUserResource());
            newItem->fromMultiPart(multipart, U("user."));
            setUser( newItem );
        }
        
    }
    
}


int64_t InventorySubscriptionResource::getBillDate() const
{
    return m_Bill_date;
}
void InventorySubscriptionResource::setBillDate(int64_t value)
{
    m_Bill_date = value;
    m_Bill_dateIsSet = true;
}
bool InventorySubscriptionResource::bill_dateIsSet() const
{
    return m_Bill_dateIsSet;
}
void InventorySubscriptionResource::unsetBill_date()
{
    m_Bill_dateIsSet = false;
}
double InventorySubscriptionResource::getCredit() const
{
    return m_Credit;
}
void InventorySubscriptionResource::setCredit(double value)
{
    m_Credit = value;
    m_CreditIsSet = true;
}
bool InventorySubscriptionResource::creditIsSet() const
{
    return m_CreditIsSet;
}
void InventorySubscriptionResource::unsetCredit()
{
    m_CreditIsSet = false;
}
std::vector<std::shared_ptr<SubscriptionCreditResource>>& InventorySubscriptionResource::getCreditLog()
{
    return m_Credit_log;
}
bool InventorySubscriptionResource::credit_logIsSet() const
{
    return m_Credit_logIsSet;
}
void InventorySubscriptionResource::unsetCredit_log()
{
    m_Credit_logIsSet = false;
}
int64_t InventorySubscriptionResource::getGraceEnd() const
{
    return m_Grace_end;
}
void InventorySubscriptionResource::setGraceEnd(int64_t value)
{
    m_Grace_end = value;
    m_Grace_endIsSet = true;
}
bool InventorySubscriptionResource::grace_endIsSet() const
{
    return m_Grace_endIsSet;
}
void InventorySubscriptionResource::unsetGrace_end()
{
    m_Grace_endIsSet = false;
}
int32_t InventorySubscriptionResource::getInventoryId() const
{
    return m_Inventory_id;
}
void InventorySubscriptionResource::setInventoryId(int32_t value)
{
    m_Inventory_id = value;
    m_Inventory_idIsSet = true;
}
bool InventorySubscriptionResource::inventory_idIsSet() const
{
    return m_Inventory_idIsSet;
}
void InventorySubscriptionResource::unsetInventory_id()
{
    m_Inventory_idIsSet = false;
}
utility::string_t InventorySubscriptionResource::getInventoryStatus() const
{
    return m_Inventory_status;
}
void InventorySubscriptionResource::setInventoryStatus(utility::string_t value)
{
    m_Inventory_status = value;
    m_Inventory_statusIsSet = true;
}
bool InventorySubscriptionResource::inventory_statusIsSet() const
{
    return m_Inventory_statusIsSet;
}
void InventorySubscriptionResource::unsetInventory_status()
{
    m_Inventory_statusIsSet = false;
}
int32_t InventorySubscriptionResource::getItemId() const
{
    return m_Item_id;
}
void InventorySubscriptionResource::setItemId(int32_t value)
{
    m_Item_id = value;
    m_Item_idIsSet = true;
}
bool InventorySubscriptionResource::item_idIsSet() const
{
    return m_Item_idIsSet;
}
void InventorySubscriptionResource::unsetItem_id()
{
    m_Item_idIsSet = false;
}
std::shared_ptr<PaymentMethodResource> InventorySubscriptionResource::getPaymentMethod() const
{
    return m_Payment_method;
}
void InventorySubscriptionResource::setPaymentMethod(std::shared_ptr<PaymentMethodResource> value)
{
    m_Payment_method = value;
    m_Payment_methodIsSet = true;
}
bool InventorySubscriptionResource::payment_methodIsSet() const
{
    return m_Payment_methodIsSet;
}
void InventorySubscriptionResource::unsetPayment_method()
{
    m_Payment_methodIsSet = false;
}
double InventorySubscriptionResource::getRecurringPrice() const
{
    return m_Recurring_price;
}
void InventorySubscriptionResource::setRecurringPrice(double value)
{
    m_Recurring_price = value;
    m_Recurring_priceIsSet = true;
}
bool InventorySubscriptionResource::recurring_priceIsSet() const
{
    return m_Recurring_priceIsSet;
}
void InventorySubscriptionResource::unsetRecurring_price()
{
    m_Recurring_priceIsSet = false;
}
utility::string_t InventorySubscriptionResource::getSku() const
{
    return m_Sku;
}
void InventorySubscriptionResource::setSku(utility::string_t value)
{
    m_Sku = value;
    m_SkuIsSet = true;
}
bool InventorySubscriptionResource::skuIsSet() const
{
    return m_SkuIsSet;
}
void InventorySubscriptionResource::unsetSku()
{
    m_SkuIsSet = false;
}
int64_t InventorySubscriptionResource::getStartDate() const
{
    return m_Start_date;
}
void InventorySubscriptionResource::setStartDate(int64_t value)
{
    m_Start_date = value;
    m_Start_dateIsSet = true;
}
bool InventorySubscriptionResource::start_dateIsSet() const
{
    return m_Start_dateIsSet;
}
void InventorySubscriptionResource::unsetStart_date()
{
    m_Start_dateIsSet = false;
}
int32_t InventorySubscriptionResource::getSubscriptionStatus() const
{
    return m_Subscription_status;
}
void InventorySubscriptionResource::setSubscriptionStatus(int32_t value)
{
    m_Subscription_status = value;
    m_Subscription_statusIsSet = true;
}
bool InventorySubscriptionResource::subscription_statusIsSet() const
{
    return m_Subscription_statusIsSet;
}
void InventorySubscriptionResource::unsetSubscription_status()
{
    m_Subscription_statusIsSet = false;
}
std::shared_ptr<SimpleUserResource> InventorySubscriptionResource::getUser() const
{
    return m_User;
}
void InventorySubscriptionResource::setUser(std::shared_ptr<SimpleUserResource> value)
{
    m_User = value;
    m_UserIsSet = true;
}
bool InventorySubscriptionResource::userIsSet() const
{
    return m_UserIsSet;
}
void InventorySubscriptionResource::unsetUser()
{
    m_UserIsSet = false;
}

}
}
}
}

