/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator 2.3.0-SNAPSHOT.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/*
 * StoreApi.h
 *
 * 
 */

#ifndef StoreApi_H_
#define StoreApi_H_


#include "ApiClient.h"

#include "BehaviorDefinitionResource.h"
#include "InvoiceResource.h"
#include "PageResource«StoreItemTemplateResource».h"
#include "PageResource«StoreItem».h"
#include "QuickBuyRequest.h"
#include "Result.h"
#include "StoreItem.h"
#include "StoreItemTemplateResource.h"
#include <cpprest/details/basic_types.h>

namespace com {
namespace knetikcloud {
namespace client {
namespace api {

using namespace com::knetikcloud::client::model;

class  StoreApi
{
public:
    StoreApi( std::shared_ptr<ApiClient> apiClient );
    virtual ~StoreApi();
    /// <summary>
    /// Create an item template
    /// </summary>
    /// <remarks>
    /// Item Templates define a type of item and the properties they have.
    /// </remarks>
    /// <param name="itemTemplateResource">The new item template (optional)</param>
    pplx::task<std::shared_ptr<StoreItemTemplateResource>> createItemTemplate(std::shared_ptr<StoreItemTemplateResource> itemTemplateResource);
    /// <summary>
    /// Create a store item
    /// </summary>
    /// <remarks>
    /// SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \&quot;parameters\&quot; field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:&lt;br /&gt; {..., parameters: [[{item: 1, skus: [\&quot;SKU-1\&quot;]}]]}&lt;br /&gt; If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints.
    /// </remarks>
    /// <param name="cascade">Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values. (optional, default to false)</param>/// <param name="storeItem">The store item object (optional)</param>
    pplx::task<std::shared_ptr<StoreItem>> createStoreItem(bool cascade, std::shared_ptr<StoreItem> storeItem);
    /// <summary>
    /// Delete an item template
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">The id of the template</param>/// <param name="cascade">force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach (optional)</param>
    pplx::task<void> deleteItemTemplate(utility::string_t id, utility::string_t cascade);
    /// <summary>
    /// Delete a store item
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">The id of the item</param>
    pplx::task<void> deleteStoreItem(int32_t id);
    /// <summary>
    /// List available item behaviors
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    
    pplx::task<std::vector<std::shared_ptr<BehaviorDefinitionResource>>> getBehaviors();
    /// <summary>
    /// Get a single item template
    /// </summary>
    /// <remarks>
    /// Item Templates define a type of item and the properties they have.
    /// </remarks>
    /// <param name="id">The id of the template</param>
    pplx::task<std::shared_ptr<StoreItemTemplateResource>> getItemTemplate(utility::string_t id);
    /// <summary>
    /// List and search item templates
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="size">The number of objects returned per page (optional, default to 25)</param>/// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>/// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
    pplx::task<std::shared_ptr<PageResource«StoreItemTemplateResource»>> getItemTemplates(int32_t size, int32_t page, utility::string_t order);
    /// <summary>
    /// Get a single store item
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">The id of the item</param>
    pplx::task<std::shared_ptr<StoreItem>> getStoreItem(int32_t id);
    /// <summary>
    /// List and search store items
    /// </summary>
    /// <remarks>
    /// If called without permission STORE_ADMIN the only items marked displayable, whose start and end date are null or appropriate to the current date, and whose geo policy allows the caller&#39;s country will be returned. Similarly skus will be filtered, possibly resulting in an item returned with no skus the user can purchase.
    /// </remarks>
    /// <param name="filterNameSearch">Filter for items whose name starts with a given string. (optional)</param>/// <param name="filterUniqueKey">Filter for items whose unique_key is a given string. (optional)</param>/// <param name="filterPublished">Filter for skus that have been published. (optional)</param>/// <param name="filterDisplayable">Filter for items that are displayable. (optional)</param>/// <param name="filterStart">A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ). (optional)</param>/// <param name="filterEnd">A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ). (optional)</param>/// <param name="filterStartDate">A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ). (optional)</param>/// <param name="filterStopDate">A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ). (optional)</param>/// <param name="filterSku">Filter for skus whose name starts with a given string. (optional)</param>/// <param name="filterPrice">A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ). (optional)</param>/// <param name="filterTag">A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags. (optional)</param>/// <param name="filterItemsByType">Filter for item type based on its type hint. (optional)</param>/// <param name="filterBundledSkus">Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39; (optional)</param>/// <param name="filterVendor">Filter for items from a given vendor, by id. (optional)</param>/// <param name="size">The number of objects returned per page (optional, default to 25)</param>/// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>/// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
    pplx::task<std::shared_ptr<PageResource«StoreItem»>> getStoreItems(utility::string_t filterNameSearch, utility::string_t filterUniqueKey, bool filterPublished, bool filterDisplayable, utility::string_t filterStart, utility::string_t filterEnd, utility::string_t filterStartDate, utility::string_t filterStopDate, utility::string_t filterSku, utility::string_t filterPrice, utility::string_t filterTag, utility::string_t filterItemsByType, utility::string_t filterBundledSkus, int32_t filterVendor, int32_t size, int32_t page, utility::string_t order);
    /// <summary>
    /// One-step purchase and pay for a single SKU item from a user&#39;s wallet
    /// </summary>
    /// <remarks>
    /// Used to create and automatically pay an invoice for a single unit of a single SKU from a user&#39;s wallet. SKU must be priced in virtual currency and must not be an item that requires shipping. PAYMENTS_ADMIN permission is required if user ID is specified and is not the ID of the currently logged in user. If invoice price does not match expected price, purchase is aborted
    /// </remarks>
    /// <param name="quickBuyRequest">Quick buy details (optional)</param>
    pplx::task<std::shared_ptr<InvoiceResource>> quickBuy(std::shared_ptr<QuickBuyRequest> quickBuyRequest);
    /// <summary>
    /// Update an item template
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">The id of the template</param>/// <param name="itemTemplateResource">The item template resource object (optional)</param>
    pplx::task<std::shared_ptr<StoreItemTemplateResource>> updateItemTemplate(utility::string_t id, std::shared_ptr<StoreItemTemplateResource> itemTemplateResource);
    /// <summary>
    /// Update a store item
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">The id of the item</param>/// <param name="cascade">Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values. (optional, default to false)</param>/// <param name="storeItem">The store item object (optional)</param>
    pplx::task<std::shared_ptr<StoreItem>> updateStoreItem(int32_t id, bool cascade, std::shared_ptr<StoreItem> storeItem);

protected:
    std::shared_ptr<ApiClient> m_ApiClient;
};

}
}
}
}

#endif /* StoreApi_H_ */

