/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/*
 * QuestionResource.h
 *
 * 
 */

#ifndef QuestionResource_H_
#define QuestionResource_H_


#include "ModelBase.h"

#include "NestedCategory.h"
#include <cpprest/details/basic_types.h>
#include <map>
#include "AnswerResource.h"
#include <vector>
#include "Property.h"

namespace io {
namespace swagger {
namespace client {
namespace model {

/// <summary>
/// 
/// </summary>
class  QuestionResource
    : public ModelBase
{
public:
    QuestionResource();
    virtual ~QuestionResource();

    /////////////////////////////////////////////
    /// ModelBase overrides

    void validate() override;

    web::json::value toJson() const override;
    void fromJson(web::json::value& json) override;

    void toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) const override;
    void fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) override;

    /////////////////////////////////////////////
    /// QuestionResource members

    /// <summary>
    /// A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    /// </summary>
    std::map<utility::string_t, std::shared_ptr<Property>>& getAdditionalProperties();
    bool additional_propertiesIsSet() const;
    void unsetAdditional_properties();
    /// <summary>
    /// The list of available answers
    /// </summary>
    std::vector<std::shared_ptr<AnswerResource>>& getAnswers();
    bool answersIsSet() const;
    void unsetAnswers();
    /// <summary>
    /// The category for the question
    /// </summary>
    std::shared_ptr<NestedCategory> getCategory() const;
    void setCategory(std::shared_ptr<NestedCategory> value);
        /// <summary>
    /// The date/time this resource was created in seconds since unix epoch
    /// </summary>
    int64_t getCreatedDate() const;
    void setCreatedDate(int64_t value);
    bool created_dateIsSet() const;
    void unsetCreated_date();
    /// <summary>
    /// The difficulty of the question
    /// </summary>
    int32_t getDifficulty() const;
    void setDifficulty(int32_t value);
        /// <summary>
    /// The unique ID for that resource
    /// </summary>
    utility::string_t getId() const;
    void setId(utility::string_t value);
    bool idIsSet() const;
    void unsetId();
    /// <summary>
    /// The id of the import job that created the question, or null if not from an import
    /// </summary>
    int64_t getImportId() const;
    void setImportId(int64_t value);
    bool import_idIsSet() const;
    void unsetImport_id();
    /// <summary>
    /// When the question becomes available, null for never, in seconds since epoch
    /// </summary>
    int64_t getPublishedDate() const;
    void setPublishedDate(int64_t value);
    bool published_dateIsSet() const;
    void unsetPublished_date();
    /// <summary>
    /// The question. Different &#39;type&#39; values indicate different structures as the question may be test, image, etc. See information on additional properties for the list and their structures
    /// </summary>
    std::shared_ptr<Property> getQuestion() const;
    void setQuestion(std::shared_ptr<Property> value);
        /// <summary>
    /// The first source of the question
    /// </summary>
    utility::string_t getSource1() const;
    void setSource1(utility::string_t value);
    bool source1IsSet() const;
    void unsetSource1();
    /// <summary>
    /// The second source of the question
    /// </summary>
    utility::string_t getSource2() const;
    void setSource2(utility::string_t value);
    bool source2IsSet() const;
    void unsetSource2();
    /// <summary>
    /// The list of tags
    /// </summary>
    std::vector<utility::string_t>& getTags();
    bool tagsIsSet() const;
    void unsetTags();
    /// <summary>
    /// A question template this question is validated against (private). May be null and no validation of additional_properties will be done
    /// </summary>
    utility::string_t getTemplate() const;
    void setTemplate(utility::string_t value);
    bool templateIsSet() const;
    void unsetTemplate();
    /// <summary>
    /// The date/time this resource was last updated in seconds since unix epoch
    /// </summary>
    int64_t getUpdatedDate() const;
    void setUpdatedDate(int64_t value);
    bool updated_dateIsSet() const;
    void unsetUpdated_date();
    /// <summary>
    /// The supplier of the question
    /// </summary>
    utility::string_t getVendor() const;
    void setVendor(utility::string_t value);
    bool vendorIsSet() const;
    void unsetVendor();

protected:
    std::map<utility::string_t, std::shared_ptr<Property>> m_Additional_properties;
    bool m_Additional_propertiesIsSet;
std::vector<std::shared_ptr<AnswerResource>> m_Answers;
    bool m_AnswersIsSet;
std::shared_ptr<NestedCategory> m_Category;
    int64_t m_Created_date;
    bool m_Created_dateIsSet;
int32_t m_Difficulty;
    utility::string_t m_Id;
    bool m_IdIsSet;
int64_t m_Import_id;
    bool m_Import_idIsSet;
int64_t m_Published_date;
    bool m_Published_dateIsSet;
std::shared_ptr<Property> m_Question;
    utility::string_t m_Source1;
    bool m_Source1IsSet;
utility::string_t m_Source2;
    bool m_Source2IsSet;
std::vector<utility::string_t> m_Tags;
    bool m_TagsIsSet;
utility::string_t m_Template;
    bool m_TemplateIsSet;
int64_t m_Updated_date;
    bool m_Updated_dateIsSet;
utility::string_t m_Vendor;
    bool m_VendorIsSet;
};

}
}
}
}

#endif /* QuestionResource_H_ */
