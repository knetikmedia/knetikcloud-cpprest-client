/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator 2.3.0-SNAPSHOT.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/*
 * CoreActivityOccurrenceSettings.h
 *
 * 
 */

#ifndef CoreActivityOccurrenceSettings_H_
#define CoreActivityOccurrenceSettings_H_


#include "ModelBase.h"

#include <cpprest/details/basic_types.h>

namespace com {
namespace knetikcloud {
namespace client {
namespace model {

/// <summary>
/// 
/// </summary>
class  CoreActivityOccurrenceSettings
    : public ModelBase
{
public:
    CoreActivityOccurrenceSettings();
    virtual ~CoreActivityOccurrenceSettings();

    /////////////////////////////////////////////
    /// ModelBase overrides

    void validate() override;

    web::json::value toJson() const override;
    void fromJson(web::json::value& json) override;

    void toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) const override;
    void fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) override;

    /////////////////////////////////////////////
    /// CoreActivityOccurrenceSettings members

    /// <summary>
    /// Whether the host can boot another user while the status is PLAYING. Must be false or null unless this setting is true in activity (or challenge if applicable). Null to inherit
    /// </summary>
    bool getBootInPlay() const;
    bool bootInPlayIsSet() const;
    void unsetBoot_in_play();
    void setBootInPlay(bool value);
    /// <summary>
    /// A custom address (url, ip or whatever is needed in your game) that users should connect to to play in this occurrence rather than the usual game server. Could be the ip address of the host for peer-to-peer play. Can only be set if the activity/challenge custom_launch_address_allowed is true. Max length: 255
    /// </summary>
    utility::string_t getCustomLaunchAddress() const;
    bool customLaunchAddressIsSet() const;
    void unsetCustom_launch_address();
    void setCustomLaunchAddress(utility::string_t value);
    /// <summary>
    /// Restriction for whether the host has control of the status once the game launches. If false they can only manage the game before (when setup and open). Cannot be true if activity/challenge has it false. Null to inherit
    /// </summary>
    bool getHostStatusControl() const;
    bool hostStatusControlIsSet() const;
    void unsetHost_status_control();
    void setHostStatusControl(bool value);
    /// <summary>
    /// Whether users can join while the status is PLAYING. Must be false or null unless this setting is true in activity (or challenge if applicable). Null to inherit
    /// </summary>
    bool getJoinInPlay() const;
    bool joinInPlayIsSet() const;
    void unsetJoin_in_play();
    void setJoinInPlay(bool value);
    /// <summary>
    /// Whether users can leave while the status is PLAYING. Must be false or null unless this setting is true in activity (or challenge if applicable). Null to inherit
    /// </summary>
    bool getLeaveInPlay() const;
    bool leaveInPlayIsSet() const;
    void unsetLeave_in_play();
    void setLeaveInPlay(bool value);
    /// <summary>
    /// The maximum number of players the game can hold. Must be equal or less than activity (or must match challenge if applicable)
    /// </summary>
    int32_t getMaxPlayers() const;
    bool maxPlayersIsSet() const;
    void unsetMax_players();
    void setMaxPlayers(int32_t value);
    /// <summary>
    /// The minimum number of players the game can hold. Must be equal or greater than activity (or must match challenge if applicable)
    /// </summary>
    int32_t getMinPlayers() const;
    bool minPlayersIsSet() const;
    void unsetMin_players();
    void setMinPlayers(int32_t value);
    /// <summary>
    /// Restriction for whether the non-host players can control of the status in place of the host. Default: false
    /// </summary>
    bool getNonHostStatusControl() const;
    bool nonHostStatusControlIsSet() const;
    void unsetNon_host_status_control();
    void setNonHostStatusControl(bool value);
    /// <summary>
    /// Restriction for who is able to report game end and results. Admin is always able to send results as well. Must be equal or more restrictive than activity (or must match challenge if applicable). Default inherits
    /// </summary>
    utility::string_t getResultsTrust() const;
    bool resultsTrustIsSet() const;
    void unsetResults_trust();
    void setResultsTrust(utility::string_t value);

protected:
    bool m_Boot_in_play;
    bool m_Boot_in_playIsSet;
    utility::string_t m_Custom_launch_address;
    bool m_Custom_launch_addressIsSet;
    bool m_Host_status_control;
    bool m_Host_status_controlIsSet;
    bool m_Join_in_play;
    bool m_Join_in_playIsSet;
    bool m_Leave_in_play;
    bool m_Leave_in_playIsSet;
    int32_t m_Max_players;
    bool m_Max_playersIsSet;
    int32_t m_Min_players;
    bool m_Min_playersIsSet;
    bool m_Non_host_status_control;
    bool m_Non_host_status_controlIsSet;
    utility::string_t m_Results_trust;
    bool m_Results_trustIsSet;
};

}
}
}
}

#endif /* CoreActivityOccurrenceSettings_H_ */
