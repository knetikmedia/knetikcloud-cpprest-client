/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator 2.2.3.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/*
 * StoreItem.h
 *
 * 
 */

#ifndef StoreItem_H_
#define StoreItem_H_


#include "Behavior.h"
#include "Sku.h"
#include <cpprest/details/basic_types.h>
#include <map>
#include <vector>
#include "Property.h"
#include "Item.h"

namespace com {
namespace knetikcloud {
namespace client {
namespace model {

/// <summary>
/// 
/// </summary>
class  StoreItem
    : public Item
{
public:
    StoreItem();
    virtual ~StoreItem();

    /////////////////////////////////////////////
    /// ModelBase overrides

    void validate() override;

    web::json::value toJson() const override;
    void fromJson(web::json::value& json) override;

    void toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) const override;
    void fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) override;

    /////////////////////////////////////////////
    /// StoreItem members

    /// <summary>
    /// Whether or not the item is currently displayable.  Default &#x3D; true
    /// </summary>
    bool getDisplayable() const;
    bool displayableIsSet() const;
    void unsetDisplayable();
    void setDisplayable(bool value);
    /// <summary>
    /// A list of country ID to include in the blacklist/whitelist geo policy
    /// </summary>
    std::vector<utility::string_t>& getGeoCountryList();
    bool geoCountryListIsSet() const;
    void unsetGeo_country_list();
    void setGeoCountryList(std::vector<utility::string_t> value);
    /// <summary>
    /// Whether to use the geo_country_list as a black list or white list for item geographical availability
    /// </summary>
    utility::string_t getGeoPolicyType() const;
    bool geoPolicyTypeIsSet() const;
    void unsetGeo_policy_type();
    void setGeoPolicyType(utility::string_t value);
    /// <summary>
    /// Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default &#x3D; 0
    /// </summary>
    int32_t getShippingTier() const;
    bool shippingTierIsSet() const;
    void unsetShipping_tier();
    void setShippingTier(int32_t value);
    /// <summary>
    /// The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
    /// </summary>
    std::vector<std::shared_ptr<Sku>>& getSkus();
        void setSkus(std::vector<std::shared_ptr<Sku>> value);
    /// <summary>
    /// The date the item will leave the store, unix timestamp in seconds.  If set to null, item will never leave the store
    /// </summary>
    int64_t getStoreEnd() const;
    bool storeEndIsSet() const;
    void unsetStore_end();
    void setStoreEnd(int64_t value);
    /// <summary>
    /// The date the item will appear in the store, unix timestamp in seconds.  If set to null, item will appear in store immediately
    /// </summary>
    int64_t getStoreStart() const;
    bool storeStartIsSet() const;
    void unsetStore_start();
    void setStoreStart(int64_t value);
    /// <summary>
    /// The vendor who provides the item
    /// </summary>
    int32_t getVendorId() const;
        void setVendorId(int32_t value);

protected:
    bool m_Displayable;
    bool m_DisplayableIsSet;
    std::vector<utility::string_t> m_Geo_country_list;
    bool m_Geo_country_listIsSet;
    utility::string_t m_Geo_policy_type;
    bool m_Geo_policy_typeIsSet;
    int32_t m_Shipping_tier;
    bool m_Shipping_tierIsSet;
    std::vector<std::shared_ptr<Sku>> m_Skus;
        int64_t m_Store_end;
    bool m_Store_endIsSet;
    int64_t m_Store_start;
    bool m_Store_startIsSet;
    int32_t m_Vendor_id;
    };

}
}
}
}

#endif /* StoreItem_H_ */
